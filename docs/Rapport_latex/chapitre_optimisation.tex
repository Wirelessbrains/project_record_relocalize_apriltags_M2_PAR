\newpage
\section{Otmizacao e trajetoria }


Apos um visualizaçao em que um camera se move em uma trajetoria que se 
paraece com incosaedro, durante a visualizaçao foi garantido que a todo
momento a camera ve pelo menos duas tags;

A primeira etapa a realizar é fazer mapaemento do nosso ambiente. Sendo 
assim, definir a primeira tag referencia o calculadas tranformaçoes 
relativas para as tags subsequentes. dado que eu sei onde todas as tags 
estao localizada posiçao e orientaçao, eu posso localizar o meu 
robo no ambiente.

A problemantica é que o robo nao consegue ver todas as tags ao mesmo tempo 
e também, dado que o robo ve as tags em sequencia pequenos erros de 
detecçao da posicao do robo sao acumulados a medida em que o robo se
move

Logo o mapaemento deve ser em caideia fazendo as transformada de referencial
a partir de uma tag referencia, ou a tag mundo.

A camera é colocada como pose de referencia e recebe a pose relativa da
tagA, primeira tag vista, ao mesmo tempo, é possivel ver a tagB, Assim
atraves destas poses é possivel cacula a pose da tag B em relaçao a tagA:

\begin{equation}
    T_{A \to B} = T_{Cam \to A}^{-1} * T_{Cam \to B}
\end{equation}

\begin{itemize}
    \item $T_{A \to B} = (R_A, \bm{t}_A)$: Pose da Tag B em relaçao a A.
    \item $T_{Cam \to A} = (R_A, \bm{t}_A)$: Pose da Tag A vista pela Câmera.
    \item $T_{Cam \to B} = (R_B, \bm{t}_B)$: Pose da Tag B vista pela Câmera.
    \item $R$: Matriz de rotaçao
    \item $t$: Vetor de posiçao
\end{itemize}

A tranformaçao de inveresa é caculada da seguinte forma:

\begin{equation}
    T^{-1} = (R^T, -R^T \bm{t})
\end{equation}

dada que o as orientaçoes das tags sao dadas em quartenion, é feita a conversao 
para matrizes de rotacao:


\begin{equation}
R = \begin{bmatrix}
q_0^2 + q_1^2 - q_2^2 - q_3^2 & 2(q_1q_2 - q_0q_3) & 2(q_0q_2 + q_1q_3) \\
2(q_1q_2 + q_0q_3) & q_0^2 - q_1^2 + q_2^2 - q_3^2 & 2(q_2q_3 - q_0q_1) \\
2(q_1q_3 - q_0q_2) & 2(q_0q_1 + q_2q_3) & q_0^2 - q_1^2 - q_2^2 + q_3^2
\end{bmatrix}
\end{equation}

Assim é possivel calcular a rotaçao relativa($R_{rel}$):

\begin{equation}                                                          
R_{rel} = R_A^T R_B                                                   
\end{equation}

Dado que a detecao da tag também nos fornece a posiçao, assim também
é possivel calcular: a translaçao relativa ($\bm{t}_{rel}$):

\begin{equation}                                                          
     \bm{t}_{rel} = R_A^T (\bm{t}_B - \bm{t}_A)                            
\end{equation}

Assim

\begin{equation}
    T_{A \to B} = (R_{rel}, \bm{t}_{rel})
\end{equation}

também é possivel realisar o calculo atravez de matrizes de transformação homogenea:

                                                          
                                                             
                   
\begin{equation}
\begin{bmatrix} 
R_{rel} & \bm{t}_{rel} \\ 
\mathbf{0}_{1 \times 3} & 1 
\end{bmatrix} = 
\begin{bmatrix} 
R_A & \bm{t}_A \\ 
\mathbf{0}_{1 \times 3} & 1 
\end{bmatrix}^{-1} 
\begin{bmatrix} 
R_B & \bm{t}_B \\ 
\mathbf{0}_{1 \times 3} & 1 
\end{bmatrix}
\end{equation}

Assim, dado que o nosso ambiente é conhecido, ou seja a pose das todas as trafomaçoes 
das tags sao conhecidas, de igual modo é possivel localizar a pose do robo.

A partir da detecçao da pose da tag em realçao a camera é feito uma tranformaçao
inversa da pose da tag até a camera para encontrar qual a pose da comaera em ralaçao a tag

\begin{equation}
    T_{W,C} = T_{W,T} * (T_{C,T})^{-1}
\end{equation}

Em que: 

\begin{equation}
    $T_{W,T}$ é a posição da Tag no seu mapa (onde a Tag 0 é a origem).
    $T_{C,T}$ é a detecção (a Tag vista pela Câmera).
    $(T_{C,T})^{-1}$ é a pose da Câmera em relação à Tag.
\end{equation}

Se a tag que a camera vé nao é a tag zero, mas dado que o ambiente foi mapeado, sabemos a pose
desta tag em relaçao a tag0 e asse por meio de tranformaçao inversa é possivel calcular a pose 
da camera.

Para pose da camera quanto mais tags forem vista mais precisao temos para a pose da camera,
visto que podemos calcular a media da pose da camera no mundo em ralaçao a cada tag. Por 
um metodo chamado SLERP, que envolve a converçao da rotaçao para quartenion. 

As matrizes de rotação $\mathbf{R} \in SO(3)$ obtidas do sistema de visão são convertidas para quaternions unitários $\mathbf{q} = [w, x, y, z]^T$.
 Dada uma matriz $\mathbf{R}$ com elementos $r_{ij}$, o componente escalar $w$ é calculado a partir do traço da matriz ($Tr(\mathbf{R})$):

\begin{equation}
    w = \frac{1}{2} \sqrt{1 + r_{11} + r_{22} + r_{33}}
\end{equation}
Os demais componentes $(x, y, z)$ são derivados das diferenças entre os elementos simétricos da matriz:
\begin{equation}
    x = \frac{r_{32} - r_{23}}{4w}, \quad y = \frac{r_{13} - r_{31}}{4w}, \quad z = \frac{r_{21} - r_{12}}{4w}
\end{equation}

\subsubsection{Média da Translação (Posição)}

A posição final da câmera é calculada através da média aritmética simples das estimativas de posição $\mathbf{p}_1$ e $\mathbf{p}_2$:
\begin{equation}
    \mathbf{p}_{avg} = \frac{\mathbf{p}_1 + \mathbf{p}_2}{2}
\end{equation}

\subsubsection{Interpolação Esférica Linear (SLERP)}
Para a rotação, utiliza-se o \textit{Spherical Linear Interpolation} (SLERP), que realiza a interpolação ao longo do arco da hiperesfera unitária. Para duas rotações $\mathbf{q}_1$ e $\mathbf{q}_2$ com fator de peso $t=0.5$:

\begin{enumerate}
    \item \textbf{Caminho Curto:} Calcula-se o produto escalar $\cos(\theta) = \mathbf{q}_1 \cdot \mathbf{q}_2$. Se $\cos(\theta) < 0$, inverte-se o sinal de um dos quaternions ($\mathbf{q}_2 = -\mathbf{q}_2$) para garantir o caminho mais curto.
    \item \textbf{Cálculo do SLERP:}
    \begin{equation}
        \mathbf{q}_{avg} = \frac{\sin((1-t)\theta)}{\sin(\theta)}\mathbf{q}_1 + \frac{\sin(t\theta)}{\sin(\theta)}\mathbf{q}_2
    \end{equation}
\end{enumerate}


\subsection{1. Otimização do Grafo de Poses}
O objetivo é encontrar as poses globais das tags $T_w^i$ que minimizam o erro de consistência com as medidas relativas $Z_{ij}$ obtidas pela mediana das observações.

\subsubsection{Vetor de Estado (Por que 6 parâmetros e não 7?)}
Embora uma pose rígida seja composta por translação (3) e quaternion (4), o vetor de otimização $\mathbf{x}$ utiliza 6 parâmetros por tag para evitar superparametrização e a restrição de norma unitária do quaternion ($\|q\|=1$), que tornaria o Jacobiano singular.

A rotação é parametrizada no espaço tangente $\mathfrak{so}(3)$ (Vetor de Rotação ou \textit{Axis-Angle}):
\begin{equation}
    \mathbf{x} = [\mathbf{v}_1^T, \mathbf{t}_1^T, \dots, \mathbf{v}_N^T, \mathbf{t}_N^T]^T
\end{equation}
Onde $\mathbf{v}_i \in \mathbb{R}^3$. Durante a otimização, $\mathbf{v}_i$ é convertido para matriz de rotação via exponencial map $R_i = \exp([\mathbf{v}_i]_\times)$ para cálculo do erro.

\subsubsection{Conversão: Rotação $\leftrightarrow$ Vetor (Exponencial e Logarítmico)}

Para transitar entre o vetor de estado $\mathbf{v}$ e as matrizes de rotação $R$, utiliza-se a Fórmula de Rodrigues e o logaritmo de matrizes.

\subsubsection{2. Matriz $\to$ Vetor de Rotação (Log Map)}
Usada para converter a matriz de erro em um vetor residual minimizável.
\begin{equation}
    \theta = \arccos\left(\frac{\text{Tr}(R) - 1}{2}\right), \quad \mathbf{u} = \frac{1}{2\sin(\theta)} \begin{bmatrix} r_{32} - r_{23} \ r_{13} - r_{31} \ r_{21} - r_{12} \end{bmatrix}
\end{equation}

\subsubsection{3. Quaternion $\to$ Vetor de Rotação}
Usada na inicialização para converter o chute inicial (quaternion) em estado do solver.
\begin{equation}
    \theta = 2 \arccos(w), \quad \mathbf{v} = \theta \cdot \frac{[x, y, z]^T}{\sin(\theta/2)}
\end{equation}

\subsubsection{4. Vetor de Rotação $\to$ Quaternion}
Usada na saída para salvar o resultado final.
\begin{equation}
    w = \cos(\theta/2), \quad [x, y, z]^T = \sin(\theta/2) \cdot \mathbf{u}
\end{equation}

\subsubsection{Função de Resíduo e Seus Termos}
Para uma aresta conectando a Tag $i$ à Tag $j$ com medição $Z_{ij} = (\hat{R}_{ij}, \hat{\bm{t}}_{ij})$, o resíduo $\mathbf{r}_{ij}$ é composto por:

\begin{itemize}
    \item \textbf{Erro de Posição:} Diferença vetorial entre a posição da tag $j$ projetada no referencial de $i$ e a medição.
    \begin{equation}
        \mathbf{r}_{pos} = \underbrace{R_i^T (\mathbf{t}_j - \mathbf{t}_i)}_{\text{Predição Local}} - \underbrace{\hat{\bm{t}}_{ij}}_{\text{Medição}}
    \end{equation}
    \begin{itemize}
        \item $R_i^T$: Rotaciona o vetor de diferença global $(\mathbf{t}_j - \mathbf{t}_i)$ para o referencial local da Tag $i$, permitindo comparação direta com a medição do sensor $\hat{\bm{t}}_{ij}$.
    \end{itemize}
    
    \item \textbf{Erro de Rotação:} Desvio angular necessário para alinhar a rotação estimada com a medida.
    \begin{equation}
        \mathbf{r}_{rot} = \lambda \cdot \text{rotvec}(\underbrace{(\hat{R}_{ij})^T R_i^T R_j}_{\text{Matriz de Erro}})
    \end{equation}
    \begin{itemize}
        \item $(\hat{R}_{ij})^T R_i^T R_j$: Produto que resulta na matriz identidade se o alinhamento for perfeito.
        \item $\lambda$: Fator de ponderação (\texttt{rotation_weight}) que equilibra a magnitude do erro angular (radianos) com o erro linear (metros).
    \end{itemize}
\end{itemize}

\subsubsection{Função de Custo Robusta (Fórmula de Huber)}
Minimiza-se a função de custo global utilizando a Perda de Huber $\rho_\delta$ para rejeição de \textit{outliers} (erros grosseiros):
\begin{equation}
    F(\mathbf{x}) = \frac{1}{2} \sum_{(i,j) \in \mathcal{E}} \rho_\delta 
 ( w_{ij} (\|\mathbf{r}_{pos}\|^2 + \|\mathbf{r}_{rot}\|^2) )
\end{equation}
A função $\rho_\delta$ evita que erros grandes "puxem" a solução, comportando-se linearmente para erros acima do limiar $\delta$:
\begin{equation}
    \rho_\delta(s) = \begin{cases} s & \text{se } s \le \delta^2 \text{ (Quadrático/Gaussiano)} \ 2\delta(\sqrt{s} - \frac{\delta}{2}) & \text{se } s > \delta^2 \text{ (Linear/Robust)} \end{cases}
\end{equation}
O termo $\delta$ (\texttt{huber_scale}) define o limite entre um erro aceitável (ruído gaussiano) e um \textit{outlier}.

\subsection{2. Processo de Atualização (Solução Numérica)}
A minimização é realizada iterativamente pelo algoritmo \textit{Trust Region Reflective}. Em cada iteração $k$:

\begin{enumerate}
    \item \textbf{Jacobiano ($J$):} Calcula-se a matriz de derivadas parciais $J = \frac{\partial \mathbf{r}}{\partial \mathbf{x}}$. Esta matriz indica a sensibilidade do erro em relação a cada variável de estado.
    \item \textbf{Passo ($\Delta \mathbf{x}$):} Resolve-se o sistema linear aproximado para encontrar o passo de ajuste, onde $\mu$ é o fator de amortecimento (\textit{damping}):
    \begin{equation}
        (J^T J + \mu I) \Delta \mathbf{x} = -J^T \mathbf{r}
    \end{equation}
    \item \textbf{Atualização:} As variáveis são atualizadas somando o passo ao estado atual:
    \begin{equation}
        \mathbf{x}_{k+1} = \mathbf{x}_{k} + \Delta \mathbf{x}
    \end{equation}
    Como usamos o vetor de rotação $\mathbf{v}$, a atualização da rotação é uma simples soma vetorial no espaço $\mathbb{R}^3$, livre de restrições de norma.
\end{enumerate}